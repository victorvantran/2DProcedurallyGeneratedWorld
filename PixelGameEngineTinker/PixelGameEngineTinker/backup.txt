#pragma once

#include <cstdint>
#include <vector>
#include <set>

#include "olcPixelGameEngine.h"
#include "Settings.h"
#include "DynamicObject.h"
// #include "World.h"

#include "BoundingBox.h"


class World;

class SpatialPartition
{
private:
	World* _world;
	std::vector<DynamicObject*> _mObjectsInArea[Settings::SpatialPartition::NUM_SPACE_ROWS * Settings::SpatialPartition::NUM_SPACE_COLS];
	//std::vector<olc::v2d_generic<long double>> _mOverlappingAreas;
	std::set<std::int64_t> _mOverlappingAreas;
	std::vector<std::int64_t> _index;

public:
	SpatialPartition()
		: _world( nullptr ),
		_mObjectsInArea{},
		_mOverlappingAreas(),
		_index()
	{

	}


	SpatialPartition( World* world )
		: _world( world ),
		_mObjectsInArea{},
		_mOverlappingAreas(),
		_index()
	{

	}


	~SpatialPartition()
	{
	}



	void updateSpaces( DynamicObject* object )
	{
		// [!] needs to be on thread that updates worldchunk, focal chunk, etc.
		// Assume object cannot be bigger than partition

		WorldChunk* topLeftWorldChunk = this->_world->getRelativeWorldChunks( 0 );

		olc::v2d_generic<long double> offset = olc::v2d_generic<long double>{ ( long double )topLeftWorldChunk->getChunkIndexX(), ( long double )topLeftWorldChunk->getChunkIndexY() };


		olc::v2d_generic<long double> objectCenter = olc::v2d_generic<long double>{ ( long double )object->getAABB().getCenter().x, ( long double )object->getAABB().getCenter().y } - offset;
		olc::v2d_generic<long double> objectHalfSize = olc::v2d_generic<long double>{ ( long double )object->getAABB().getHalfSize().x, ( long double )object->getAABB().getHalfSize().y };

		// Check for objects out of world bounds and ignore
		BoundingBox<long double> worldBounds( 0, 0, Settings::SpatialPartition::NUM_SPACE_COLS * Settings::SpatialPartition::WIDTH, Settings::SpatialPartition::NUM_SPACE_ROWS * Settings::SpatialPartition::HEIGHT );
		if ( worldBounds.encapsulates( BoundingBox<long double>{ objectCenter.x - objectHalfSize.x, objectCenter.y - objectHalfSize.y, objectHalfSize.x * 2, objectHalfSize.y * 2 } ) )
		{
			return;
		}


		olc::v2d_generic<long double> topLeft = objectCenter + olc::v2d_generic<long double>{ -objectHalfSize.x, -objectHalfSize.y };
		olc::v2d_generic<long double> topRight = objectCenter + olc::v2d_generic<long double>{ objectHalfSize.x, -objectHalfSize.y };
		olc::v2d_generic<long double> bottomLeft = objectCenter + olc::v2d_generic<long double>{ -objectHalfSize.x, objectHalfSize.y };
		olc::v2d_generic<long double> bottomRight = objectCenter + olc::v2d_generic<long double>{ -objectHalfSize.x, objectHalfSize.y };

		topLeft.x /= Settings::SpatialPartition::WIDTH;
		topLeft.y /= Settings::SpatialPartition::HEIGHT;
		topRight.x /= Settings::SpatialPartition::WIDTH;
		topRight.y /= Settings::SpatialPartition::HEIGHT;
		bottomLeft.x /= Settings::SpatialPartition::WIDTH;
		bottomLeft.y /= Settings::SpatialPartition::HEIGHT;
		bottomRight.x = topRight.x;
		bottomRight.y = bottomLeft.y;

		if ( ( std::int64_t )topLeft.x == ( std::int64_t )topRight.x && ( std::int64_t )topLeft.y == ( std::int64_t )bottomLeft.y )
		{
			this->_mOverlappingAreas.insert( ( std::int64_t )topLeft.y * Settings::SpatialPartition::NUM_SPACE_COLS + ( std::int64_t )topLeft.x );
		}
		else if ( ( std::int64_t )topLeft.x == ( std::int64_t )topRight.x )
		{
			this->_mOverlappingAreas.insert( ( std::int64_t )topLeft.y * Settings::SpatialPartition::NUM_SPACE_COLS + ( std::int64_t )topLeft.x );
			this->_mOverlappingAreas.insert( ( std::int64_t )bottomLeft.y * Settings::SpatialPartition::NUM_SPACE_COLS + ( std::int64_t )bottomLeft.x );
			//this->_mOverlappingAreas.insert( topLeft );
			//this->_mOverlappingAreas.insert( bottomLeft );
		}
		else if ( ( std::int64_t )topLeft.y == ( std::int64_t )bottomLeft.y )
		{
			this->_mOverlappingAreas.insert( ( std::int64_t )topLeft.y * Settings::SpatialPartition::NUM_SPACE_COLS + ( std::int64_t )topLeft.x );
			this->_mOverlappingAreas.insert( ( std::int64_t )topRight.y * Settings::SpatialPartition::NUM_SPACE_COLS + ( std::int64_t )topRight.x );
			//this->_mOverlappingAreas.insert( topLeft );
			//this->_mOverlappingAreas.insert( topRight );
		}
		else
		{
			this->_mOverlappingAreas.insert( ( std::int64_t )topLeft.y * Settings::SpatialPartition::NUM_SPACE_COLS + ( std::int64_t )topLeft.x );
			this->_mOverlappingAreas.insert( ( std::int64_t )bottomLeft.y * Settings::SpatialPartition::NUM_SPACE_COLS + ( std::int64_t )bottomLeft.x );
			this->_mOverlappingAreas.insert( ( std::int64_t )topRight.y * Settings::SpatialPartition::NUM_SPACE_COLS + ( std::int64_t )topRight.x );
			this->_mOverlappingAreas.insert( ( std::int64_t )bottomRight.y * Settings::SpatialPartition::NUM_SPACE_COLS + ( std::int64_t )bottomRight.x );
			//this->_mOverlappingAreas.insert( topLeft );
			//this->_mOverlappingAreas.insert( bottomLeft );
			//this->_mOverlappingAreas.insert( topRight );
			//this->_mOverlappingAreas.insert( bottomRight );
		}



		std::set<std::pair<std::int64_t, std::size_t>>& spaces = object->getSpaces();
		std::set<std::pair<std::int64_t, std::size_t>>::iterator spacesIter = spaces.begin();
		while ( spacesIter != spaces.end() )
		{
			if ( this->_mOverlappingAreas.find( (*spacesIter).first ) == this->_mOverlappingAreas.end() )
			{
				spaces.erase( spacesIter );
			}
			else
			{
				spacesIter++;
			}
		}



		/*
		std::set<std::pair<std::int64_t,std::size_t>>& spaces = object->getSpaces();

		for ( const std::pair<std::int64_t, std::size_t> space : spaces )
		{
			if ( this->_mOverlappingAreas.find( space.first ) == this->_mOverlappingAreas.end() )
			{
				this->removeObjectFromSpace( space.first, space.second, object );
				spaces.erase( space );
			}
		}
		*/




		// Loop through old areas and remove if object no longer overlaps
		/*

		std::set<std::int64_t>& spaces = object->getSpaces();
		std::set<std::size_t>& idsInSpaces = object->getIdsInSpaces();


		std::set<std::int64_t>::iterator spacesIter;
		std::set<std::size_t>::iterator idsInSpacesIter;
		std::size_t i;
		for ( i = 0, spacesIter = spaces.begin(), idsInSpacesIter = idsInSpaces.begin(); spacesIter != spaces.end() && idsInSpacesIter != idsInSpaces.end(); )
		{
			if ( this->_mOverlappingAreas.find( spaces[i] ) == this->_mOverlappingAreas.end() )
			{
				this->removeObjectFromSpace( spaces[i], idsInSpaces[i], object );
				spaces.erase( spacesIter++ );
				idsInSpaces.erase( idsInSpacesIter++ );
			}
			else
			{
				i++;
			}
		}
		*/



		// Loop through new areas to add any potentional overlapping spaces
		for ( std::int64_t spaceIndex : this->_mOverlappingAreas )
		{

			std::set<std::pair<std::int64_t, std::size_t>>::iterator spacesIt = std::find_if( spaces.begin(), spaces.end(), [&] ( const std::pair<std::int64_t, std::size_t>& p ) { return p.first == spaceIndex; } );
			if ( spacesIt != spaces.end() )
			{
				this->addObjectToSpace( spaceIndex, object );
			}

			/*
			if ( spaces.find( std::pair<std::int64_t, std::size_t>{ spaceIndex, } ) == spaces.end() )
			{
				this->addObjectToSpace( spaceIndex, object );;

			}
			*/
		}

		this->_mOverlappingAreas.clear();

	}


	void addObjectToSpace( std::int64_t spaceIndex, DynamicObject* object )
	{
		// Adds object to a particular paritioned space
		std::vector<DynamicObject*> space = this->_mObjectsInArea[spaceIndex];

		object->addToSpaces( spaceIndex );
		object->addToIdsInSpaces( space.size() );
		space.push_back( object );
	}



	void removeObjectFromSpace( std::int64_t spaceIndex, std::size_t objectIndexInSpace, DynamicObject* object )
	{
		// Removes object to a particular paritioned space ( swapping with last object in vector )
		std::vector<DynamicObject*> space = this->_mObjectsInArea[spaceIndex];

		// Swap
		DynamicObject* lastObject = space[space.size() - 1];
		space[space.size() - 1] = object;
		space[objectIndexInSpace] = lastObject;

		// Update the swapped object's areas
		/*
		std::set<std::int64_t>& tempSpaces = object->getSpaces();
		std::set<std::size_t>& tempIdsInSpaces = object->getIdsInSpaces();
		for ( std::size_t i = 0; i < tempSpaces.size(); i++ )
		{
			if ( tempSpaces[i] == spaceIndex )
			{
				tempIdsInSpaces[i] = objectIndexInSpace;
				break;
			}
		}
		*/

		std::set<std::pair<std::int64_t, std::size_t>>& tempSpaces = object->getSpaces();
		std::set<std::pair<std::int64_t, std::size_t>>::iterator spacesIt = std::find_if( tempSpaces.begin(), tempSpaces.end(), [&] ( const std::pair<std::int64_t, std::size_t>& p ) { return p.first == spaceIndex; } );
		if ( spacesIt != tempSpaces.end() )
		{
			tempSpaces.erase( spacesIt );
			tempSpaces.insert( std::pair<std::int64_t, std::size_t>{ spaceIndex, objectIndexInSpace } );
		}


		// Remove the swapped last object
		space.pop_back();
	}
};
